Die Engine besteht aus sieben Hauptkomponenten: Graphics, Physics, Processmanager, Eventmanager, Controller, Timer und die Engine selbst. 
Diese Komponenten erben von der Klasse EngineElement. Diese Klasse enthält als Attribute eine Prozess-ID und eine Instanz von sich selbst, auf welche über getInstance zugegriffen wird. Ausserdem sind Methoden zum Initialisieren und Beenden der Komponenten vorhanden, welche im Konstruktor EngineElement als Eventcallbacks registriert werden. Die run-Funktion wird als Process registriert, dessen id abgespeichert wird. 
Alle Komponenten werden als Referenz in Engine abgespeichert. Über Getter-Methoden kann auf diese zugegriffen werden. 
Graphics enthält eine Liste aller Graphicsobjects. Diese können über addGraphicsobject oder removeGraphicsobject hinzugefügt oder entfernt werden. Mit drawScene werden die Graphicsobjects über deren render Funktion gezeichnet, während mit clear der Bildschirm geleert wird. Die Graphicsobejcts enthalten eine zu zeichnende Texture und einen Counter, wie auch eine Methode runAnimation, welche zum Darstellen einer Animation erforderlich sind. 
Physics enthält eine Liste aller Physicsobjects. Über die Methode simulateNext wird die Physik-Szenerie aktualisiert. Mit simulateNextNSteps wird dieser Schritt N-Mal wiederholt und abgespeichert, um so eine Vorrausberechnung zu erhalten. Dabei wird auf Kollisionen mit der Methode checkforCollisions geprüft. Über addPhysicsobject und removePhysicsobject können Physicsobjects hinzugefügt oder entfernt werden. Die Attribute hullbox, static und weight spezifizieren die Eigenschaften eines Physicsobjects. 
Der Processmanager enthält eine Liste mit allen Prozessen. Über removeProcess und addProcess können Prozesse hinzugefügt oder entfernt werden. RunProcesses verarbeitet alle Processe. Solche Prozesse enthalten selbst Referenzen auf Objekte von Klassen, die das Interface ProcessOwner implementieren und somit über eine aufzurufende Callback Funktion verfügen. 
Der Eventmanager enthält eine Liste aller Events und einen Vektor aller Eventlistener. Über registerListener und unregisterListener können Eventlistener hinzugefügt oder entfernt werden. Diese werden im Eventlistenervector abgespeichert.  Eine Klasse die das Interface Eventlistener implementiert enthält eine Callback Funktion, welche beim Triggern des Events mit einer bestimmten ID aufgerufen wird. Dies passiert in der Methode processEvents, in der die eventlist abgearbeitet wird. 
Der Controller enthält einen Vektor in dem alle Controls gespeichert sind, sowie eine Referenz auf die zurzeit aktiven Controls. Über setControls und addControls können Controls hinzugefügt und aktiviert werden. Solche Controls enthalten einen Vektor, der (Maus)Tasten auf Events mappt, was durch die Methode setControl definiert wird. 
Der Timer gibt die Frequenz des Programms vor, welche über setFrequence und getFrequence gesetzt und abgerufen werden kann. Die Methode waitTimer wartet die restliche Zeit bis zum nächsten Tick. 